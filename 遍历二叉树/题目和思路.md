# Problems and Ideas

## 2158 二叉树的中序遍历

**描述**：输入完全二叉树的层次遍历，将空节点用-1补全。输出二叉树的中序遍历。

**基本思路**：对完全二叉树的层次遍历顺次编号为0~n-1，则由下标关系可得父节点与左右子节点间关系，同时根据下标的奇偶性能判断该节点为左子还是右子。因此不需要通过辅助栈记忆路径。

### 解法一 标记已访问节点

注意到在中序遍历的递归解法中，对右子树的遍历是尾递归，因此改为迭代版本时，只需着重分析从根节点出发到第一次对某个右子的访问，剩下的过程就是回退并逐个访问右子树。首先，沿着左子走到最底端。（暂称该路径为左子路径），此节点为空，退回父节点并输出父节点。
父节点访问完毕，再尝试访问右子，若右子树非空，则以右子为新的根节点进行下一轮中序遍历；若否，沿着左子路径回退至上一节点，访问它及它的右子。回退后，为防止再次沿左子路径向下走，将已访问节点设为空节点（修改数据有违遍历的要求，下一个解法中会解决这个问题）
当然，回退时还有另一种可能，即当前节点为某右子树的根节点，作为左子路径上某节点的右子，因此在回退时需要另行判断该节点的左右子身份，决定回退方式。
从这里可以看到，与使用栈相比，这种直接通过下标进行访问决策的方法，需要考虑回退路径问题，而在栈中，直接后继被压栈顺序安排好，当访问到空节点时无新节点入栈，于是通过出栈进行回退，不用考虑回退方式。

### 解法二 安排好回退路径

修改节点的解法能获得正确输出，但没能很好解决回退方式的问题。在理解了为什么出栈能统一实现不同方式的回退后，只需要把不同的回退情况都考虑一遍，就能实现真正的遍历。
由于每次迭代的开始，都要沿着左子路径走到底，因此从已访问的右子树回退时，不能只回退到左子路径，还应直接寻找下一个非空右子树，若无非空右子树，则回退至根节点，并跳回上一层的左子路径。
当回退到下标为零的节点，说明遍历结束。

### 其他

三种遍历顺序来自深度优先搜索DFS，在对二叉树的DFS中，每个内部节点被前进步骤forward step访问一次，被回退步骤backward step访问两次，因此，在哪一次访问时输出该节点就决定了三种遍历顺序。
由于DFS的规则能被写为每一步发生后的决策规则，而关于DFS的许多性质可由数学归纳法给出，因此一种遍历可由局部规则决定，同时能递归地进行。
而对递归写法的改写，最直接的办法是手动维护一个节点栈代替函数栈，同时为每个节点新增一个标识位，标记访问次数（在不改变节点的构成字段（struct Node）时，可通过平行地维护一个整型数据栈实现），按次数决定是否输出。
若要更有针对性地改写，就只能把递归过程展开，进行尾递归优化，再想办法改写近似尾递归的部分。

## 2160 林中寻宝

**描述**：输入拓展二叉树的前序遍历，输出其深度。拓展二叉树即将空节点用-1补全。

**基本思路**：通过出入栈模拟遍历过程，不断更新遍历深度，记录其最大值。

### 解法

前序遍历先沿左子路径进行访问，每访问一节点，压栈一次，高度加一。当遇到第一个空节点时高度不变。此时左子为空，尝试访问右子。
若右子也为空，栈顶为两个连续的-1，说明访问了叶节点，应回退，高度减一。这样，每积累两个-1就回退三个节点，然后增加一个-1，将已访问分支标记为空避免再次访问。
这样，当出现两个-1时，除了表明叶节点外，还可以表明该子树已访问完毕，进行回退。当回退至根节点，遍历完成，结束高度记录。
